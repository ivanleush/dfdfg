import logging
from aiogram import Dispatcher, types, F
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession

from app.config import settings
from app.states import BalanceStates
from app.database.crud.user import add_user_balance
from app.database.crud.transaction import (
    get_user_transactions, get_user_transactions_count,
    create_transaction
)
from app.database.models import User, TransactionType, PaymentMethod
from app.keyboards.inline import (
    get_balance_keyboard, get_payment_methods_keyboard,
    get_back_keyboard, get_pagination_keyboard
)
from app.localization.texts import get_texts
from app.services.payment_service import PaymentService
from app.utils.pagination import paginate_list
from app.utils.decorators import error_handler

from app.services.crypto_payment_service import CryptoPaymentService, TON_TO_RUB_EXCHANGE_RATE
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from app.database.crud.user import get_user_by_telegram_id

logger = logging.getLogger(__name__)
router = Router()

TRANSACTIONS_PER_PAGE = 10

class TopupStates(StatesGroup):
    choosing_method = State()
    waiting_for_amount = State()


@router.callback_query(F.data == "topup_crypto")
async def start_crypto_payment(callback: types.CallbackQuery, state: FSMContext, db_user: User):
    await state.set_state(TopupStates.waiting_for_amount)

    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π "–ù–∞–∑–∞–¥"
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚Ü©Ô∏è –ù–∞–∑–∞–¥", callback_data="balance_topup")]
    ])

    await callback.message.edit_text(
        "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –≤ —Ä—É–±–ª—è—Ö:",
        reply_markup=keyboard  # –ü—Ä–∏–∫—Ä–µ–ø–ª—è–µ–º –Ω–æ–≤—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    )
    await callback.answer()

@router.message(TopupStates.waiting_for_amount, F.text.regexp(r"^\d+(\.\d{1,2})?$"))
async def process_amount(message: types.Message, state: FSMContext, db_user: User):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª—É—á–∞–µ—Ç —Å—É–º–º—É –∏ —Å–æ–∑–¥–∞–µ—Ç —Å—á–µ—Ç."""
    try:
        amount_rub = float(message.text)
        if amount_rub <= 0:
            await message.answer("–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–º —á–∏—Å–ª–æ–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
            return

        amount_ton = amount_rub / TON_TO_RUB_EXCHANGE_RATE

        service = CryptoPaymentService()
        invoice = await service.create_invoice(amount_ton, db_user.telegram_id)

        if invoice:
            await message.answer(
                f"‚úÖ –°–æ–∑–¥–∞–Ω —Å—á–µ—Ç –Ω–∞ {amount_rub} ‚ÇΩ (~{amount_ton:.4f} TON).\n"
                f"–ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –¥–ª—è –æ–ø–ª–∞—Ç—ã:\n"
                f"üîó {invoice['pay_url']}",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                    [
                        InlineKeyboardButton(
                            text="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–ª–∞—Ç–µ–∂",
                            callback_data=f"check_crypto_{invoice['invoice_id']}"
                        )
                    ]
                ])
            )
            # ‚úÖ –¢–µ–ø–µ—Ä—å –º—ã —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å—É–º–º—É –≤ –∫–æ–ø–µ–π–∫–∞—Ö –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞—á–∏—Å–ª–µ–Ω–∏—è
            await state.update_data(amount_kopeks=int(amount_rub * 100))
            # ‚ùå –í–∞–∂–Ω–æ! –ù–µ –æ—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∑–¥–µ—Å—å
        else:
            await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—á–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")

    except ValueError:
        await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 100 –∏–ª–∏ 150.50).")


@router.callback_query(F.data.startswith("check_crypto_"))
async def check_crypto_payment_handler(callback: types.CallbackQuery, state: FSMContext, db: AsyncSession):
    try:
        logger.info(f"–¢–∏–ø callback: {type(callback)}")
        logger.info(f"Callback data: {callback.data}")
        logger.info(f"User ID: {callback.from_user.id}")

        invoice_id = int(callback.data.split("_")[-1])
        service = CryptoPaymentService()
        status = await service.check_invoice_status(invoice_id)

        logger.info(f"–°—Ç–∞—Ç—É—Å —Å—á–µ—Ç–∞ {invoice_id}: {status}")

        if status == "paid":
            db_user = await get_user_by_telegram_id(db, callback.from_user.id)
            data = await state.get_data()
            amount_kopeks = data.get('amount_kopeks')

            if db_user and amount_kopeks is not None:
                # ‚úÖ –ü–ï–†–ï–î–ê–ï–ú –û–ë–™–ï–ö–¢ USER, –ê –ù–ï ID
                success = await add_user_balance(db, db_user, amount_kopeks)

                if success:
                    await db.commit()
                    await state.clear()

                    await callback.message.edit_text(
                        "üéâ –ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –∑–∞—á–∏—Å–ª–µ–Ω –Ω–∞ –≤–∞—à –±–∞–ª–∞–Ω—Å!",
                        reply_markup=get_balance_keyboard()
                    )
                    await callback.answer("–ü–ª–∞—Ç–µ–∂ –∑–∞—á–∏—Å–ª–µ–Ω!")
                else:
                    await callback.answer(
                        "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞—á–∏—Å–ª–µ–Ω–∏–∏ —Å—Ä–µ–¥—Å—Ç–≤. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.",
                        show_alert=True
                    )
            else:
                await callback.answer(
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–ª–∞—Ç–µ–∂–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.",
                    show_alert=True
                )
        elif status == "active":
            await callback.answer(
                "‚è≥ –ü–ª–∞—Ç–µ–∂ –µ—â–µ –Ω–µ –ø–æ—Å—Ç—É–ø–∏–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —á–µ—Ä–µ–∑ 1-2 –º–∏–Ω—É—Ç—ã.",
                show_alert=True
            )
        else:
            await callback.answer(
                "‚ùå –ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –∏—Å—Ç–µ–∫. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π —Å—á–µ—Ç.",
                show_alert=True
            )

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∫—Ä–∏–ø—Ç–æ-–ø–ª–∞—Ç–µ–∂–∞: {e}")
        await callback.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–ª–∞—Ç–µ–∂–∞.", show_alert=True)

@error_handler
async def show_balance_menu(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession
):
    texts = get_texts(db_user.language)
    
    balance_text = texts.BALANCE_INFO.format(
        balance=texts.format_price(db_user.balance_kopeks)
    )
    
    await callback.message.edit_text(
        balance_text,
        reply_markup=get_balance_keyboard(db_user.language)
    )
    await callback.answer()


@error_handler
async def show_balance_history(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession,
    page: int = 1
):
    texts = get_texts(db_user.language)
    
    offset = (page - 1) * TRANSACTIONS_PER_PAGE
    
    raw_transactions = await get_user_transactions(
        db, db_user.id, 
        limit=TRANSACTIONS_PER_PAGE * 3, 
        offset=offset
    )
    
    seen_transactions = set()
    unique_transactions = []
    
    for transaction in raw_transactions:
        rounded_time = transaction.created_at.replace(second=0, microsecond=0)
        transaction_key = (
            transaction.amount_kopeks,
            transaction.description,
            rounded_time
        )
        
        if transaction_key not in seen_transactions:
            seen_transactions.add(transaction_key)
            unique_transactions.append(transaction)
            
            if len(unique_transactions) >= TRANSACTIONS_PER_PAGE:
                break
    
    all_transactions = await get_user_transactions(db, db_user.id, limit=1000)
    seen_all = set()
    total_unique = 0
    
    for transaction in all_transactions:
        rounded_time = transaction.created_at.replace(second=0, microsecond=0)
        transaction_key = (
            transaction.amount_kopeks,
            transaction.description,
            rounded_time
        )
        if transaction_key not in seen_all:
            seen_all.add(transaction_key)
            total_unique += 1
    
    if not unique_transactions:
        await callback.message.edit_text(
            "üìä –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π –ø—É—Å—Ç–∞",
            reply_markup=get_back_keyboard(db_user.language)
        )
        await callback.answer()
        return
    
    text = "üìä <b>–ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π</b>\n\n"
    
    for transaction in unique_transactions:
        emoji = "üí∞" if transaction.type == TransactionType.DEPOSIT.value else "üí∏"
        amount_text = f"+{texts.format_price(transaction.amount_kopeks)}" if transaction.type == TransactionType.DEPOSIT.value else f"-{texts.format_price(transaction.amount_kopeks)}"
        
        text += f"{emoji} {amount_text}\n"
        text += f"üìù {transaction.description}\n"
        text += f"üìÖ {transaction.created_at.strftime('%d.%m.%Y %H:%M')}\n\n"
    
    keyboard = []
    total_pages = (total_unique + TRANSACTIONS_PER_PAGE - 1) // TRANSACTIONS_PER_PAGE
    
    if total_pages > 1:
        pagination_row = get_pagination_keyboard(
            page, total_pages, "balance_history", db_user.language
        )
        keyboard.extend(pagination_row)
    
    keyboard.append([
        types.InlineKeyboardButton(text=texts.BACK, callback_data="menu_balance")
    ])
    
    await callback.message.edit_text(
        text,
        reply_markup=types.InlineKeyboardMarkup(inline_keyboard=keyboard),
        parse_mode="HTML"
    )
    await callback.answer()


@error_handler
async def handle_balance_history_pagination(
    callback: types.CallbackQuery,
    db_user: User,
    db: AsyncSession
):
    page = int(callback.data.split('_')[-1])
    await show_balance_history(callback, db_user, db, page)


@error_handler
async def show_payment_methods(
    callback: types.CallbackQuery,
    db_user: User,
    state: FSMContext
):
    texts = get_texts(db_user.language)
    
    payment_text = """
üí≥ <b>–°–ø–æ—Å–æ–±—ã –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞</b>

–í—ã–±–µ—Ä–∏—Ç–µ —É–¥–æ–±–Ω—ã–π –¥–ª—è –≤–∞—Å —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:

‚≠ê <b>Telegram Stars</b> - –±—ã—Å—Ç—Ä–æ –∏ —É–¥–æ–±–Ω–æ
üí≥ <b>–ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞</b> - —á–µ—Ä–µ–∑ YooKassa/Tribute
üõ†Ô∏è <b>–ß–µ—Ä–µ–∑ –ø–æ–¥–¥–µ—Ä–∂–∫—É</b> - –¥—Ä—É–≥–∏–µ —Å–ø–æ—Å–æ–±—ã

–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:
"""
    
    await callback.message.edit_text(
        payment_text,
        reply_markup=get_payment_methods_keyboard(0, db_user.language), 
        parse_mode="HTML"
    )
    await callback.answer()


@error_handler
async def start_stars_payment(
    callback: types.CallbackQuery,
    db_user: User,
    state: FSMContext
):
    texts = get_texts(db_user.language)
    
    if not settings.TELEGRAM_STARS_ENABLED:
        await callback.answer("‚ùå –ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Stars –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ", show_alert=True)
        return
    
    await callback.message.edit_text(
        texts.TOP_UP_AMOUNT,
        reply_markup=get_back_keyboard(db_user.language)
    )
    
    await state.set_state(BalanceStates.waiting_for_amount)
    await state.update_data(payment_method="stars")
    await callback.answer()


@error_handler
async def start_yookassa_payment(
    callback: types.CallbackQuery,
    db_user: User,
    state: FSMContext
):
    texts = get_texts(db_user.language)
    
    if not settings.is_yookassa_enabled():
        await callback.answer("‚ùå –û–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π —á–µ—Ä–µ–∑ YooKassa –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞", show_alert=True)
        return
    
    await callback.message.edit_text(
        "üí≥ <b>–û–ø–ª–∞—Ç–∞ –±–∞–Ω–∫–æ–≤—Å–∫–æ–π –∫–∞—Ä—Ç–æ–π</b>\n\n"
        "–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –æ—Ç 100 –¥–æ 50,000 —Ä—É–±–ª–µ–π:",
        reply_markup=get_back_keyboard(db_user.language),
        parse_mode="HTML"
    )
    
    await state.set_state(BalanceStates.waiting_for_amount)
    await state.update_data(payment_method="yookassa")
    await callback.answer()


@error_handler
async def start_tribute_payment(
    callback: types.CallbackQuery,
    db_user: User
):
    texts = get_texts(db_user.language)
    
    if not settings.TRIBUTE_ENABLED:
        await callback.answer("‚ùå –û–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞", show_alert=True)
        return
    
    try:
        from app.services.tribute_service import TributeService
        
        tribute_service = TributeService(callback.bot)
        payment_url = await tribute_service.create_payment_link(
            user_id=db_user.telegram_id,
            amount_kopeks=0,
            description="–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ VPN"
        )
        
        if not payment_url:
            await callback.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞", show_alert=True)
            return
        
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üí≥ –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ", url=payment_url)],
            [types.InlineKeyboardButton(text=texts.BACK, callback_data="balance_topup")]
        ])
        
        await callback.message.edit_text(
            f"üí≥ <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–Ω–∫–æ–≤—Å–∫–æ–π –∫–∞—Ä—Ç–æ–π</b>\n\n"
            f"‚Ä¢ –í–≤–µ–¥–∏—Ç–µ –ª—é–±—É—é —Å—É–º–º—É –æ—Ç 100‚ÇΩ\n"
            f"‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ Tribute\n"
            f"‚Ä¢ –ú–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ –∑–∞—á–∏—Å–ª–µ–Ω–∏–µ –Ω–∞ –±–∞–ª–∞–Ω—Å\n"
            f"‚Ä¢ –ü—Ä–∏–Ω–∏–º–∞–µ–º –∫–∞—Ä—Ç—ã Visa, MasterCard, –ú–ò–†\n\n"
            f"‚Ä¢ üö® –ù–ï –û–¢–ü–†–ê–í–õ–Ø–¢–¨ –ü–õ–ê–¢–ï–ñ –ê–ù–û–ù–ò–ú–ù–û!\n\n"
            f"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –æ–ø–ª–∞—Ç–µ:",
            reply_markup=keyboard,
            parse_mode="HTML"
        )
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è Tribute –ø–ª–∞—Ç–µ–∂–∞: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞", show_alert=True)
    
    await callback.answer()


@error_handler
async def request_support_topup(
    callback: types.CallbackQuery,
    db_user: User
):
    texts = get_texts(db_user.language)
    
    support_text = f"""
üõ†Ô∏è <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –ø–æ–¥–¥–µ—Ä–∂–∫—É</b>

–î–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É:
{settings.SUPPORT_USERNAME}

–£–∫–∞–∂–∏—Ç–µ:
‚Ä¢ ID: {db_user.telegram_id}
‚Ä¢ –°—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è
‚Ä¢ –°–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã

‚è∞ –í—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏: 1-24 —á–∞—Å–∞

<b>–î–æ—Å—Ç—É–ø–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã:</b>
‚Ä¢ –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞
‚Ä¢ –ü–µ—Ä–µ–≤–æ–¥—ã –º–µ–∂–¥—É –±–∞–Ω–∫–∞–º–∏
‚Ä¢ –î—Ä—É–≥–∏–µ –ø–ª–∞—Ç–µ–∂–Ω—ã–µ —Å–∏—Å—Ç–µ–º—ã
"""
    
    keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
        [types.InlineKeyboardButton(
            text="üí¨ –ù–∞–ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É", 
            url=f"https://t.me/{settings.SUPPORT_USERNAME.lstrip('@')}"
        )],
        [types.InlineKeyboardButton(text=texts.BACK, callback_data="balance_topup")]
    ])
    
    await callback.message.edit_text(
        support_text,
        reply_markup=keyboard,
        parse_mode="HTML"
    )
    await callback.answer()


@error_handler
async def process_topup_amount(
    message: types.Message,
    db_user: User,
    state: FSMContext
):
    texts = get_texts(db_user.language)
    
    try:
        amount_rubles = float(message.text.replace(',', '.'))
        
        if amount_rubles < 1:
            await message.answer("–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 1 ‚ÇΩ")
            return
        
        if amount_rubles > 50000:
            await message.answer("–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: 50,000 ‚ÇΩ")
            return
        
        amount_kopeks = int(amount_rubles * 100)
        data = await state.get_data()
        payment_method = data.get("payment_method", "stars")
        
        if payment_method == "stars":
            await process_stars_payment_amount(message, db_user, amount_kopeks, state)
        elif payment_method == "yookassa":
            from app.database.database import AsyncSessionLocal
            async with AsyncSessionLocal() as db:
                await process_yookassa_payment_amount(message, db_user, db, amount_kopeks, state)
        else:
            await message.answer("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã")
        
    except ValueError:
        await message.answer(
            texts.INVALID_AMOUNT,
            reply_markup=get_back_keyboard(db_user.language)
        )

@error_handler
async def process_stars_payment_amount(
    message: types.Message,
    db_user: User,
    amount_kopeks: int,
    state: FSMContext
):
    texts = get_texts(db_user.language)
    
    if not settings.TELEGRAM_STARS_ENABLED:
        await message.answer("‚ö† –û–ø–ª–∞—Ç–∞ Stars –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
        return
    
    try:
        from app.external.telegram_stars import TelegramStarsService
        
        amount_rubles = amount_kopeks / 100
        stars_amount = TelegramStarsService.calculate_stars_from_rubles(amount_rubles)
        
        payment_service = PaymentService(message.bot)
        invoice_link = await payment_service.create_stars_invoice(
            amount_kopeks=amount_kopeks,
            description=f"–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –Ω–∞ {texts.format_price(amount_kopeks)}",
            payload=f"balance_{db_user.id}_{amount_kopeks}"
        )
        
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="‚≠ê –û–ø–ª–∞—Ç–∏—Ç—å", url=invoice_link)],
            [types.InlineKeyboardButton(text=texts.BACK, callback_data="balance_topup")]
        ])
        
        await message.answer(
            f"‚≠ê <b>–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ Telegram Stars</b>\n\n"
            f"üí∞ –°—É–º–º–∞: {texts.format_price(amount_kopeks)}\n"
            f"‚≠ê –ö –æ–ø–ª–∞—Ç–µ: {stars_amount} –∑–≤–µ–∑–¥\n"
            f"üìä –ö—É—Ä—Å: {settings.get_stars_rate():.2f}‚ÇΩ –∑–∞ –∑–≤–µ–∑–¥—É\n\n"
            f"–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –æ–ø–ª–∞—Ç—ã:",
            reply_markup=keyboard,
            parse_mode="HTML"
        )
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è Stars invoice: {e}")
        await message.answer("‚ö† –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞")


@error_handler
async def process_yookassa_payment_amount(
    message: types.Message,
    db_user: User,
    db: AsyncSession,
    amount_kopeks: int,
    state: FSMContext
):
    texts = get_texts(db_user.language)
    
    if not settings.is_yookassa_enabled():
        await message.answer("‚ùå –û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ YooKassa –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
        return
    
    if amount_kopeks < 10000:
        await message.answer("‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –¥–ª—è –æ–ø–ª–∞—Ç—ã –∫–∞—Ä—Ç–æ–π: 100 ‚ÇΩ")
        return
    
    try:
        payment_service = PaymentService(message.bot)
        
        payment_result = await payment_service.create_yookassa_payment(
            db=db,
            user_id=db_user.id,
            amount_kopeks=amount_kopeks,
            description=settings.get_balance_payment_description(amount_kopeks),
            receipt_email=None,
            receipt_phone=None,
            metadata={
                "user_telegram_id": str(db_user.telegram_id),
                "user_username": db_user.username or "",
                "purpose": "balance_topup"
            }
        )
        
        if not payment_result:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.")
            await state.clear()
            return
        
        confirmation_url = payment_result.get("confirmation_url")
        if not confirmation_url:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Å—ã–ª–∫–∏ –¥–ª—è –æ–ø–ª–∞—Ç—ã. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.")
            await state.clear()
            return
        
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
            [types.InlineKeyboardButton(text="üí≥ –û–ø–ª–∞—Ç–∏—Ç—å –∫–∞—Ä—Ç–æ–π", url=confirmation_url)],
            [types.InlineKeyboardButton(text="üìä –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å", callback_data=f"check_yookassa_{payment_result['local_payment_id']}")],
            [types.InlineKeyboardButton(text=texts.BACK, callback_data="balance_topup")]
        ])
        
        await message.answer(
            f"üí≥ <b>–û–ø–ª–∞—Ç–∞ –±–∞–Ω–∫–æ–≤—Å–∫–æ–π –∫–∞—Ä—Ç–æ–π</b>\n\n"
            f"üí∞ –°—É–º–º–∞: {settings.format_price(amount_kopeks)}\n"
            f"üÜî ID –ø–ª–∞—Ç–µ–∂–∞: {payment_result['yookassa_payment_id'][:8]}...\n\n"
            f"üì± <b>–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:</b>\n"
            f"1. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É '–û–ø–ª–∞—Ç–∏—Ç—å –∫–∞—Ä—Ç–æ–π'\n"
            f"2. –í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –≤–∞—à–µ–π –∫–∞—Ä—Ç—ã\n"
            f"3. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –ø–ª–∞—Ç–µ–∂\n"
            f"4. –î–µ–Ω—å–≥–∏ –ø–æ—Å—Ç—É–ø—è—Ç –Ω–∞ –±–∞–ª–∞–Ω—Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n\n"
            f"üîí –û–ø–ª–∞—Ç–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —á–µ—Ä–µ–∑ –∑–∞—â–∏—â–µ–Ω–Ω—É—é —Å–∏—Å—Ç–µ–º—É YooKassa\n"
            f"‚úÖ –ü—Ä–∏–Ω–∏–º–∞–µ–º –∫–∞—Ä—Ç—ã: Visa, MasterCard, –ú–ò–†\n\n"
            f"‚ùì –ï—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –ø—Ä–æ–±–ª–µ–º—ã, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ {settings.SUPPORT_USERNAME}",
            reply_markup=keyboard,
            parse_mode="HTML"
        )
        
        await state.clear()
        
        logger.info(f"–°–æ–∑–¥–∞–Ω –ø–ª–∞—Ç–µ–∂ YooKassa –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {db_user.telegram_id}: "
                   f"{amount_kopeks/100}‚ÇΩ, ID: {payment_result['yookassa_payment_id']}")
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è YooKassa –ø–ª–∞—Ç–µ–∂–∞: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.")
        await state.clear()


@error_handler
async def check_yookassa_payment_status(
    callback: types.CallbackQuery,
    db: AsyncSession
):
    try:
        local_payment_id = int(callback.data.split('_')[-1])
        
        from app.database.crud.yookassa import get_yookassa_payment_by_local_id
        payment = await get_yookassa_payment_by_local_id(db, local_payment_id)
        
        if not payment:
            await callback.answer("‚ùå –ü–ª–∞—Ç–µ–∂ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return
        
        status_emoji = {
            "pending": "‚è≥",
            "waiting_for_capture": "‚åõ",
            "succeeded": "‚úÖ",
            "canceled": "‚ùå",
            "failed": "‚ùå"
        }
        
        status_text = {
            "pending": "–û–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—ã",
            "waiting_for_capture": "–û–∂–∏–¥–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è",
            "succeeded": "–û–ø–ª–∞—á–µ–Ω",
            "canceled": "–û—Ç–º–µ–Ω–µ–Ω",
            "failed": "–û—à–∏–±–∫–∞"
        }
        
        emoji = status_emoji.get(payment.status, "‚ùì")
        status = status_text.get(payment.status, "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
        
        message_text = (f"üí≥ –°—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞:\n\n"
                       f"üÜî ID: {payment.yookassa_payment_id[:8]}...\n"
                       f"üí∞ –°—É–º–º–∞: {settings.format_price(payment.amount_kopeks)}\n"
                       f"üìä –°—Ç–∞—Ç—É—Å: {emoji} {status}\n"
                       f"üìÖ –°–æ–∑–¥–∞–Ω: {payment.created_at.strftime('%d.%m.%Y %H:%M')}\n")
        
        if payment.is_succeeded:
            message_text += "\n‚úÖ –ü–ª–∞—Ç–µ–∂ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω!\n\n–°—Ä–µ–¥—Å—Ç–≤–∞ –∑–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ –±–∞–ª–∞–Ω—Å."
        elif payment.is_pending:
            message_text += "\n‚è≥ –ü–ª–∞—Ç–µ–∂ –æ–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—ã. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É '–û–ø–ª–∞—Ç–∏—Ç—å' –≤—ã—à–µ."
        elif payment.is_failed:
            message_text += f"\n‚ùå –ü–ª–∞—Ç–µ–∂ –Ω–µ –ø—Ä–æ—à–µ–ª. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ {settings.SUPPORT_USERNAME}"
        
        await callback.answer(message_text, show_alert=True)
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –ø–ª–∞—Ç–µ–∂–∞: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞", show_alert=True)



def register_handlers(dp: Dispatcher):
    
    dp.callback_query.register(
        show_balance_menu,
        F.data == "menu_balance"
    )
    
    dp.callback_query.register(
        show_balance_history,
        F.data == "balance_history"
    )
    
    dp.callback_query.register(
        handle_balance_history_pagination,
        F.data.startswith("balance_history_page_")
    )
    
    dp.callback_query.register(
        show_payment_methods,
        F.data == "balance_topup"
    )
    
    dp.callback_query.register(
        start_stars_payment,
        F.data == "topup_stars"
    )
    
    dp.callback_query.register(
        start_yookassa_payment,
        F.data == "topup_yookassa"
    )
    
    dp.callback_query.register(
        start_tribute_payment,
        F.data == "topup_tribute"
    )
    
    dp.callback_query.register(
        request_support_topup,
        F.data == "topup_support"
    )
    
    dp.callback_query.register(
        check_yookassa_payment_status,
        F.data.startswith("check_yookassa_")
    )
    
    dp.message.register(
        process_topup_amount,
        BalanceStates.waiting_for_amount
    )
